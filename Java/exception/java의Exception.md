
## JAVA의 Exception  

JAVA의 예외는 크게 두가지로 나뉜다. 

컴파일 시점에서 확인할 수 있는 체크예외와 런타임 시점에서 확인할 수 있는 언체크(런타임)예외.

크게 자바의 **Throwable** 클래스를 상속받는 **Exception**이 예외 클래스의 대표적인 클래스인데 

이 중에서 RuntimeException을 제외한 나머지, IOException, SQLException등이 체크예외,

그리고 RuntimeException을 상속받는 NullPointerException, IllegalArgumentException등이 언체크(런타임) 예외이다.


## 체크 예외

기본적으로 **Exception**을 상속받으면 체크 예외가 되며, 

체크 예외는 컴파일 시점에서부터 컴파일러가 개발자가 예외가 발생함을 인지할 수 있게해주는 안전 장치의 역할을 한다.

하지만 하나하나 예외를 잡거나 던져야하므로 개발자가 비중을 낮게 두거나 생각지도못한 예외까지도 다 처리해야하는 번거로움이 있다.

체크 예외는 현재 클래스에서 해결이 불가능할 경우 throw를 통해 자신을 호출한 상위 클래스로 예외를 던지거나, 

해결이 가능할 경우 try/catch 등을 이용하여 반드시 예외를 잡아줘야 한다.


## 언체크(런타임) 예외

기본적으로 **RuntimeException**을 상속받으면 언체크 예외가 되며,

언체크 예외는 이름 그대로 컴파일러가 컴파일 시점에서 예외를 잡지 않는다.

그러므로 언체크 예외는 개발자가 신경쓰고싶지않은 예외는 무시가 가능하다. 체크 예외는 현 상황에서 해결이 안될 경우 throw를 

통해 반드시 예외를 던져야하지만 언체크 예외는 throw가 생략이 가능하다. 

하지만 컴파일러가 예외를 잡지 않는다는것은 개발자가 실수로 언체크 예외를 인지하지 못하고 누락할 경우가 생긴다.

언체크 예외도 개발자가 try/catch를 통해서 잡을 수 있고, throw 구문은 생략 가능하다.


## 체크 예외의 단점

대부분의 예외는 해결이 불가능하다. 하지만 Service, Controller등이 이 예외를 알고있어야 한다.

RuntimeException을 사용하면 이런 복구 불가능한 예외를 신경쓰지않아도 된다.

<br>

마찬가지로 예외 클래스에 의존적이게 된다.

예를들어 SQLException의 경우 Repository 단에서 해결이 안된다면 Service 단으로 던져야하고 거기서도 해결이 안되면 

Controller, WAS까지 던지게 된다. 중간에서 예외를 처리한다고 해도 throw SQLException이나 try/catch에서 SQLException을 

의존하게 되고 상황이 바뀌어 JPA를 쓴다고 가정했을때 모든 코드를 변경해야한다.


## 체크 예외 문제 해결
 
초창기때는 한 눈에 알 수 있고 처리하기 편한 체크 예외가 더 좋다고 생각했지만 최근엔 해결되지않는 예외가 많고, 

관심없는 예외까지 모두 처리해야하며 해당 예외 클래스에 종속적이게 되는 단점들 때문에 RuntimeException을 사용하는 추세이다.

예를 들어 서비스단에서는 순수한 서비스 로직, 자바 코드만 구성하고 싶어도 체크 예외때문에 특정 기술에 의존적이게 된다거나

그 예외에 관한 내용까지 알고있어야한다. 

발생한 체크 예외를 런타임 예외로 변경하여 던지면 특정 기술에 의존적이라거나 관심없는 예외는 무시하여 처리할 수 있다.

스프링도 이에 관한 예외 추상화 관련 기술을 제공한다.







